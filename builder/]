use proc_macro::{Span, TokenStream};
use proc_macro2;
use syn::{
    DeriveInput,
    parse_macro_input,
    Ident,
    Data,
    Fields,
    Type,
    PathArguments,
};
use quote::{quote};

#[proc_macro_derive(Builder)]
pub fn derive(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);

    let name = &input.ident;
    let builder_name = Ident::new(&format!("{}Builder", name), Span::call_site().into());
    let err_name = Ident::new(&format!("{}BuilderError", name), Span::call_site().into());

    let fields = match input.data {
        Data::Struct(struct_data) => match struct_data.fields {
            Fields::Named(named_fields) => named_fields.named,
            _ => panic!("Expected named fields"),
        },
        _ => panic!("Expected a struct!")
    };

    let mut field_inits = Vec::<proc_macro2::TokenStream>::new();
    let mut field_idents = Vec::<proc_macro2::TokenStream>::new();
    let mut method_decls = Vec::<proc_macro2::TokenStream>::new();
    let mut build_decls = Vec::<proc_macro2::TokenStream>::new();

    fields.iter().for_each(|field| {
        let field_name = &field.ident;
        let field_ty = &field.ty;

        let optional_type = get_optional_type(field_ty);

        field_inits.push(quote! {
            #field_name: None,
        });

        field_idents.push(quote! {
            #field_name: Option<#field_ty>,
        });

        method_decls.push(quote! {
            pub fn #field_name (&mut self, #field_name: #field_ty) -> &mut Self {
                self.#field_name = Some(#field_name);
                self
            }
        });

        build_decls.push(quote! {
            #field_name: self.#field_name.take().ok_or(#err_name)?,
        });
    });

    let field_inits = field_inits.iter();
    let field_idents = field_idents.iter();
    let method_decls = method_decls.iter();
    let build_decls = build_decls.iter();

    return quote! {
        use std::error::Error;
        use std::fmt;

        impl #name {
            pub fn builder() -> #builder_name {
                return #builder_name {
                    #(#field_inits)*
                }
            }
        }

        pub struct #builder_name {
            #(#field_idents)*
        }

        #[derive(Debug, Clone)]
        pub struct #err_name;

        impl fmt::Display for #err_name {
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                write!(f, "Expected all fields to be defined.")
            }
        }

        impl #builder_name {
            fn build(&mut self) -> Result<#name, #err_name> {
                return Ok(#name {
                    #(#build_decls)*
                });
            }

            #(#method_decls)*
        }
    }.into();
}

fn get_optional_type(ty: &Type) -> Option<&Type> {
    let path = match ty {
        Type::Path(type_path) => &type_path.path,
        _ => return None,
    };

    let segments = &path.segments;
    
    if path.segments.len() != 1 {
        return None;
    }

    let first_seg = &segments[0];

    let optional_ident = Ident::new("Optional", proc_macro2::Span::call_site());
    if !optional_ident.eq(&first_seg.ident) {
        return None;
    }

    let arguments = &first_seg.arguments;
    
    let angle_bracketed = match arguments {
        PathArguments::AngleBracketed(a) => a,
        _ => return None,
    };

    let angled_args = &angle_bracketed.args;
    
    if angled_args.len() != 1 {
        return None
    }

    let first_angled_arg = &angled_args[0];

    let type = match first_angled_arg {
    };

    return first_angled;
}
